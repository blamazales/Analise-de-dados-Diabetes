# -*- coding: utf-8 -*-
"""Diabetes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q3zBxXGyAJtqYX4jyFbarAryjHGlZ713

# Análise de casos de diabetes

Informações sobre os atributos:


- Pregnancies: expressa o número de gravidezes

- Glucose: Expresa o nível de glicose no sangue

- BloodPressure: Expressa a medição de pressão sanguínea

- SkinThickness: Expressa a espessura da pele

- Insulin: Expressa o nível de insulina no corpo

- BMI: Expressa o índice de massa corporal

- DiabetesPedigreeFunction: Uma função que determina o risco de diabetes tipo 2 com base no histórico familiar. Quanto maior a função, maior o risco de diabetes tipo 2.

- Age: Expressa a idade

- Outcome: Expressa o resultado final  1 para sim e 0 para não

### Leitura do arquivo e formatação
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import scipy.stats as stat

df = pd.read_csv("/content/diabetes.csv", sep=";")

df.head()

df.columns = ['Gravidez', 'Glicose', 'Pressão', 'Espessura Pele', 'Insulina', 'IMC', 'Função Diabetes', 'Idade', 'Resultado']
df.head()

"""# Análise Descritiva dos dados"""

print(df.describe())

# Verificar a quantidade de valores nulos em cada coluna
print(df.isnull().sum())

df.hist(figsize=(12, 10))
plt.show()

correlation_matrix = df.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Matriz de Correlação')
plt.show()

"""Análise das variáveis em boxplots com e sem outliers"""

for column in df.columns:
    plt.figure(figsize=(8, 6))
    sns.boxplot(data = df , x = column, color='cyan',showfliers=True)
    plt.title(f'Boxplot de {column}')
    plt.show()

for column in df.columns:
    plt.figure(figsize=(8, 6))
    sns.boxplot(data = df , x = column, color='cyan',showfliers=False)
    plt.title(f'Boxplot de {column}')
    plt.show()

# Análise da distribuição da variável alvo (Resultado)
print(df['Resultado'].value_counts())
sns.countplot(x='Resultado', data=df)
plt.title('Distribuição do Resultado')
plt.show()

"""# Limpeza dos Dados

Remoção de valores zero que dentro da variável, não significam um valor real
"""

# Remove linhas onde 'Pressão' é 0 e cria um novo dataframe
df_new = df[df['Pressão'] != 0]

# Remove linhas onde 'Glicose' é 0 dentro do novo dataframe
df_new = df[df['Glicose'] != 0]

# Remove linhas onde 'Insulina' é 0 dentro do novo dataframe
df_new = df[df['Insulina'] != 0]

# Remove linhas onde 'IMC' é 0 dentro do novo dataframe
df_new = df[df['IMC'] != 0]

df_new.shape

"""# Remoção de outliers"""

df_copy = df_new.copy()

def find_outlier_iqr(dataset, colname):
    q25, q75 = np.quantile(dataset[colname], 0.25), np.quantile(dataset[colname], 0.75)
    # calcula  IQR
    iqr = q75 - q25
    # calcula outlier cutoff
    cut_off = iqr * 1.5
    # calcula margens inferiores, lower e superiores upper
    lower, upper = q25 - cut_off, q75 + cut_off
    print(' IQR é ',iqr)
   # print('Valor minimo', lower)
   # print('Valor maximo', upper)
    outliers = []

    for i in dataset[colname].values:
      if((i > upper)or(i < lower)):
        outliers.append(i)
    print('O numero de outliers encontrado foi de', len(outliers))
    return lower, upper, outliers

for column in df_copy.select_dtypes(include=np.number).columns:
  lower, upper, out =  find_outlier_iqr(df_copy, column)
  if (len(out) > 0):
    plt.figure(figsize = (10,6))
    sns.displot(df_copy[column], kde=False)
    plt.axvspan(xmin = lower,xmax= df_copy[column].min(),alpha=0.2, color='red')
    plt.axvspan(xmin = upper,xmax= df_copy[column].max(),alpha=0.2, color='red')
    plt.title("Outliers detectados em {}".format(column))

df_no_outliers = df_copy.copy()

for column in df_copy.select_dtypes(include=np.number).columns:
  lower, upper, outliers =  find_outlier_iqr(df_copy, column)
  if (len(outliers) > 0):
    # Remove outliers from the DataFrame
    df_no_outliers = df_no_outliers[~df_no_outliers[column].isin(outliers)]

print(f"Original DataFrame shape: {df_copy.shape}")
print(f"DataFrame without outliers shape: {df_no_outliers.shape}")

"""# Análise de Correlações entre variavéis

### Qual a distribuição da idade dos pacientes?
"""

# Qual a distribuição da idade dos pacientes?
plt.figure(figsize=(8, 6))
sns.histplot(df['Idade'], kde=True)
plt.title('Distribuição da Idade dos Pacientes')
plt.xlabel('Idade')
plt.ylabel('Frequência')
plt.show()

# Qual a distribuição da idade dos pacientes?
plt.figure(figsize=(8, 6))
sns.histplot(df_no_outliers['Idade'], kde=True)
plt.title('Distribuição da Idade dos Pacientes')
plt.xlabel('Idade')
plt.ylabel('Frequência')
plt.show()

# Medidas de tendência central e dispersão da idade
print(f"Média da idade: {df['Idade'].mean()}")
print(f"Mediana da idade: {df['Idade'].median()}")
print(f"Desvio padrão da idade: {df['Idade'].std()}")

"""### Qual a distribuição do IMC na população analisada?"""

# Qual a distribuição do IMC na população analisada?
plt.figure(figsize=(8, 6))
sns.histplot(df['IMC'], kde=True)
plt.title('Distribuição do IMC dos Pacientes')
plt.xlabel('IMC')
plt.ylabel('Frequência')
plt.show()

# Qual a distribuição do IMC na população analisada?
plt.figure(figsize=(8, 6))
sns.histplot(df_no_outliers['IMC'], kde=True)
plt.title('Distribuição do IMC dos Pacientes - sem outliers')
plt.xlabel('IMC')
plt.ylabel('Frequência')
plt.show()

# Medidas de tendência central e dispersão do IMC
print(f"Média do IMC: {df['IMC'].mean()}")
print(f"Mediana do IMC: {df['IMC'].median()}")
print(f"Desvio padrão do IMC: {df['IMC'].std()}")

# Medidas de tendência central e dispersão do IMC sem outliers
print(f"Média do IMC: {df_no_outliers['IMC'].mean()}")
print(f"Mediana do IMC: {df_no_outliers['IMC'].median()}")
print(f"Desvio padrão do IMC: {df_no_outliers['IMC'].std()}")

"""### A glicose tem correlação com o resultado da diabetes?

"""

# Calcular a correlação entre a glicose e o resultado da diabetes
correlation_glicose_resultado = df['Glicose'].corr(df['Resultado'])
print(f"Correlação entre Glicose e Resultado: {correlation_glicose_resultado}")

correlation_glicose_resultado2 = df_no_outliers['Glicose'].corr(df_no_outliers['Resultado'])
print(f"Correlação entre Glicose e Resultado: {correlation_glicose_resultado2}")

# Criar uma figura com 2 subplots lado a lado
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Gráfico 1: Com outliers
sns.scatterplot(ax=axes[0], x='Glicose', y='Resultado', data=df)
axes[0].set_title('Relação entre Glicose e Resultado (com outliers)')
axes[0].set_xlabel('Glicose')
axes[0].set_ylabel('Resultado')

# Gráfico 2: Sem outliers
sns.scatterplot(ax=axes[1], x='Glicose', y='Resultado', data=df_no_outliers)
axes[1].set_title('Relação entre Glicose e Resultado (sem outliers)')
axes[1].set_xlabel('Glicose')
axes[1].set_ylabel('Resultado')

# Ajustar espaçamento
plt.tight_layout()
plt.show()

# Criar uma figura com 2 subplots lado a lado
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Gráfico 1: Com outliers
sns.barplot(ax=axes[0], x='Resultado', y='Glicose', data=df, errorbar=None)
axes[0].set_title('Média de Glicose por Diagnóstico (com outliers)')
axes[0].set_xlabel('Resultado (0 = Sem Diabetes, 1 = Com Diabetes)')
axes[0].set_ylabel('Média da Glicose')

# Gráfico 2: Sem outliers
sns.barplot(ax=axes[1], x='Resultado', y='Glicose', data=df_no_outliers, errorbar=None)
axes[1].set_title('Média de Glicose por Diagnóstico (sem outliers)')
axes[1].set_xlabel('Resultado (0 = Sem Diabetes, 1 = Com Diabetes)')
axes[1].set_ylabel('Média da Glicose')

# Ajustar espaçamento
plt.tight_layout()
plt.show()

sns.boxplot(x="Resultado", y="Glicose", data=df)
plt.title("Distribuição da Glicose entre Diabéticos e Não Diabéticos")
plt.show()

sns.boxplot(x="Resultado", y="Glicose", data=df_no_outliers)
plt.title("Distribuição da Glicose entre Diabéticos e Não Diabéticos")
plt.show()

"""### Há alguma relação entre IMC e diabetes?

"""

# Calcular a correlação entre o IMC e o resultado da diabetes
correlation_imc_resultado = df['IMC'].corr(df['Resultado'])
print(f"Correlação entre IMC e Resultado: {correlation_imc_resultado}")

# Calcular a correlação entre o IMC e o resultado da diabetes
correlation_imc_resultado = df_no_outliers['IMC'].corr(df_no_outliers['Resultado'])
print(f"Correlação entre IMC e Resultado: {correlation_imc_resultado}")

# Criar uma figura com 2 subplots lado a lado
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Gráfico 1: Com outliers
sns.scatterplot(ax=axes[0], x='IMC', y='Resultado', data=df, alpha=0.5)
axes[0].set_title('Relação entre IMC e Resultado (com outliers)')
axes[0].set_xlabel('IMC')
axes[0].set_ylabel('Resultado')

# Gráfico 2: Sem outliers
sns.scatterplot(ax=axes[1], x='IMC', y='Resultado', data=df_no_outliers, alpha=0.5)
axes[1].set_title('Relação entre IMC e Resultado (sem outliers)')
axes[1].set_xlabel('IMC')
axes[1].set_ylabel('Resultado')

# Ajustar espaçamento
plt.tight_layout()
plt.show()

# Criar faixas de IMC
bins = [10, 18.5, 25, 30, 35, 40, 50]  # Definir intervalos
labels = ['<18.5', '18.5-24.9', '25-29.9', '30-34.9', '35-39.9', '≥40']
df['IMC_bin'] = pd.cut(df['IMC'], bins=bins, labels=labels)
df_no_outliers['IMC_bin'] = pd.cut(df_no_outliers['IMC'], bins=bins, labels=labels)

# Criar uma figura com 2 subplots lado a lado
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Gráfico 1: Com outliers
sns.barplot(ax=axes[0], x='IMC_bin', y='Resultado', data=df, errorbar=None)
axes[0].set_title('Relação entre IMC e Resultado (com outliers)')
axes[0].set_xlabel('Faixa de IMC')
axes[0].set_ylabel('Média do Resultado')

# Gráfico 2: Sem outliers
sns.barplot(ax=axes[1], x='IMC_bin', y='Resultado', data=df_no_outliers, errorbar=None)
axes[1].set_title('Relação entre IMC e Resultado (sem outliers)')
axes[1].set_xlabel('Faixa de IMC')
axes[1].set_ylabel('Média do Resultado')

# Ajustar espaçamento
plt.tight_layout()
plt.show()

"""### Pessoas mais velhas têm maior risco de diabetes?"""

correlation_idade_resultado = df['Idade'].corr(df['Resultado'])
print(f"Correlação entre Idade e Resultado: {correlation_idade_resultado}")

correlation_idade_resultado = df_no_outliers['Idade'].corr(df_no_outliers['Resultado'])
print(f"Correlação entre Idade e Resultado: {correlation_idade_resultado}")

# Criar um gráfico de dispersão para visualizar a relação
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Idade', y='Resultado', data=df)
plt.title('Relação entre Idade e Resultado da Diabetes')
plt.xlabel('Idade')
plt.ylabel('Resultado')
plt.show()

# Criar uma figura com 2 subplots lado a lado
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Gráfico 1: Com outliers
sns.boxplot(ax=axes[0], x='Resultado', y='Idade', data=df)
axes[0].set_title('Relação entre Idade e Resultado (com outliers)')
axes[0].set_xlabel('Resultado')
axes[0].set_ylabel('Idade')

# Gráfico 2: Sem outliers
sns.boxplot(ax=axes[1], x='Resultado', y='Idade', data=df_no_outliers)
axes[1].set_title('Relação entre Idade e Resultado (sem outliers)')
axes[1].set_xlabel('Resultado')
axes[1].set_ylabel('Idade')

# Ajustar espaçamento
plt.tight_layout()
plt.show()

"""### Qual a média de glicose em pessoas com e sem diabetes?

"""

# Agrupar os dados por 'Resultado' e calcular a média da glicose para cada grupo
media_glicose_por_resultado = df.groupby('Resultado')['Glicose'].mean()
media_glicose_por_resultado_new = df_no_outliers.groupby('Resultado')['Glicose'].mean()

# Imprimir os resultados
media_glicose_por_resultado

media_glicose_por_resultado_new

"""### Pessoas com diabetes tendem a ter maior IMC?

"""

# Agrupar os dados por 'Resultado' e calcular a média do IMC para cada grupo
media_imc_por_resultado = df.groupby('Resultado')['IMC'].mean()

# Imprimir os resultados
print(media_imc_por_resultado)

# Criar uma figura com 2 subplots lado a lado
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Gráfico 1: Com outliers
sns.boxplot(ax=axes[0], x='Resultado', y='IMC', data=df)
axes[0].set_title('Relação entre IMC e Resultado (com outliers)')
axes[0].set_xlabel('Resultado')
axes[0].set_ylabel('IMC')

# Gráfico 2: Sem outliers
sns.boxplot(ax=axes[1], x='Resultado', y='IMC', data=df_no_outliers, showfliers=False)
axes[1].set_title('Relação entre IMC e Resultado (sem outliers)')
axes[1].set_xlabel('Resultado')
axes[1].set_ylabel('IMC')

# Ajustar espaçamento
plt.tight_layout()
plt.show()

sns.histplot(df[df['Resultado'] == 0]['IMC'], label='Sem Diabetes', kde=True, color='blue', alpha=0.6)
sns.histplot(df[df['Resultado'] == 1]['IMC'], label='Com Diabetes', kde=True, color='red', alpha=0.6)
plt.title('Distribuição do IMC por Resultado da Diabetes')
plt.xlabel('IMC')
plt.ylabel('Frequência')
plt.legend()
plt.show()

sns.histplot(df_no_outliers[df_no_outliers['Resultado'] == 0]['IMC'], label='Sem Diabetes', kde=True, color='blue', alpha=0.6)
sns.histplot(df_no_outliers[df_no_outliers['Resultado'] == 1]['IMC'], label='Com Diabetes', kde=True, color='red', alpha=0.6)
plt.title('Distribuição do IMC por Resultado da Diabetes - sem outliers')
plt.xlabel('IMC')
plt.ylabel('Frequência')
plt.legend()
plt.show()

"""O Seaborn Boxplot ainda usa a regra do IQR para definir novos outliers dentro do subconjunto de dados filtrado.

Quando você remove os valores extremos, os quartis e a dispersão dos dados mudam.
Isso pode fazer com que alguns valores, antes considerados normais, agora sejam outliers.
O Seaborn não "sabe" que os dados foram filtrados

Ele recalcula os quartis e define os novos limites baseados na regra:
Alguns pontos ainda podem ficar fora desses novos limites.

### Há diferença na pressão arterial entre os grupos?
"""

# Calcular a média da pressão arterial para cada grupo (diabéticos e não diabéticos)
media_pressao_por_resultado = df.groupby('Resultado')['Pressão'].mean()
print(media_pressao_por_resultado)

# Calcular a média da pressão arterial para cada grupo (diabéticos e não diabéticos)
media_pressao_por_resultado_new = df_no_outliers.groupby('Resultado')['Pressão'].mean()
print(media_pressao_por_resultado_new)

# Realizar um teste t para comparar as médias das pressões arteriais entre os grupos
grupo_diabeticos = df[df['Resultado'] == 1]['Pressão']
grupo_nao_diabeticos = df[df['Resultado'] == 0]['Pressão']
t_statistic, p_value = stat.ttest_ind(grupo_diabeticos, grupo_nao_diabeticos)

print(f"Estatística t: {t_statistic}")
print(f"Valor p: {p_value}")

# Interpretar o resultado do teste t
alpha = 0.05  # Nível de significância
if p_value < alpha:
    print("Há diferença significativa na pressão arterial entre os grupos (p < 0.05).")
else:
    print("Não há diferença significativa na pressão arterial entre os grupos (p >= 0.05).")

# Realizar um teste t para comparar as médias das pressões arteriais entre os grupos
grupo_diabeticos = df_no_outliers[df_no_outliers['Resultado'] == 1]['Pressão']
grupo_nao_diabeticos = df_no_outliers[df_no_outliers['Resultado'] == 0]['Pressão']
t_statistic, p_value = stat.ttest_ind(grupo_diabeticos, grupo_nao_diabeticos)

print(f"Estatística t: {t_statistic}")
print(f"Valor p: {p_value}")

# Interpretar o resultado do teste t
alpha = 0.05  # Nível de significância
if p_value < alpha:
    print("Há diferença significativa na pressão arterial entre os grupos (p < 0.05).")
else:
    print("Não há diferença significativa na pressão arterial entre os grupos (p >= 0.05).")

# Criar uma figura com 2 subplots lado a lado
fig, axes = plt.subplots(1, 2, figsize=(14, 6))

# Gráfico 1: Com outliers
sns.boxplot(ax=axes[0], x='Resultado', y='Pressão', data=df)
axes[0].set_title('Relação entre Pressão e Resultado (com outliers)')
axes[0].set_xlabel('Resultado')
axes[0].set_ylabel('Pressão')

# Gráfico 2: Sem outliers
sns.boxplot(ax=axes[1], x='Resultado', y='Pressão', data=df_no_outliers)
axes[1].set_title('Relação entre Pressão e Resultado (sem outliers)')
axes[1].set_xlabel('Resultado')
axes[1].set_ylabel('Pressão')

# Ajustar espaçamento
plt.tight_layout()
plt.show()

"""### Quais fatores têm maior impacto na presença de diabetes?

"""

# Análise de correlação com o Resultado para identificar os fatores de maior impacto
correlation_with_result = df.corr()['Resultado'].drop('Resultado')  # Remove a autocorrelação
print(correlation_with_result.sort_values(ascending=False))

# Análise de correlação com o Resultado para identificar os fatores de maior impacto
correlation_with_result2 = df_no_outliers.corr()['Resultado'].drop('Resultado')  # Remove a autocorrelação
print(correlation_with_result2.sort_values(ascending=False))

# Visualizar as correlações com um gráfico de barras
plt.figure(figsize=(10, 6))
correlation_with_result.sort_values(ascending=False).plot(kind='bar')
plt.title('Correlação entre os fatores e o resultado da diabetes')
plt.xlabel('Fatores')
plt.ylabel('Correlação')
plt.xticks(rotation=45, ha='right')
plt.show()

"""Ao remover os outliers, a ordem dos fatores foi alterada"""

# Visualizar as correlações com um gráfico de barras
plt.figure(figsize=(10, 6))
correlation_with_result2.sort_values(ascending=False).plot(kind='bar')
plt.title('Correlação entre os fatores e o resultado da diabetes')
plt.xlabel('Fatores')
plt.ylabel('Correlação')
plt.xticks(rotation=45, ha='right')
plt.show()

"""### Existe um valor de glicose acima do qual a maioria das pessoas tem diabetes?

"""

plt.figure(figsize=(10, 5))
sns.kdeplot(df[df['Resultado'] == 1]['Glicose'], label='Diabetes', fill=True, color='red')
sns.kdeplot(df[df['Resultado'] == 0]['Glicose'], label='Sem Diabetes', fill=True, color='blue')

plt.axvline(df[df['Resultado'] == 1]['Glicose'].median(), color='darkred', linestyle='--', label='Mediana Diabetes')
plt.axvline(df[df['Resultado'] == 0]['Glicose'].median(), color='darkblue', linestyle='--', label='Mediana Sem Diabetes')

plt.legend()
plt.xlabel('Nível de Glicose')
plt.ylabel('Densidade')
plt.title('Distribuição da Glicose para Pessoas com e sem Diabetes')
plt.show()

# Calcular a média da glicose para cada grupo
media_glicose_diabeticos = df[df['Resultado'] == 1]['Glicose'].mean()
media_glicose_nao_diabeticos = df[df['Resultado'] == 0]['Glicose'].mean()
print(f"Média da Glicose em Diabéticos: {media_glicose_diabeticos}")
print(f"Média da Glicose em Não Diabéticos: {media_glicose_nao_diabeticos}")

# Analisar a glicose em relação a um limiar, por exemplo, 140
limiar_glicose = 150
pessoas_acima_limiar = df[df['Glicose'] > limiar_glicose]
proporcao_diabeticos_acima_limiar = pessoas_acima_limiar[pessoas_acima_limiar['Resultado']==1].shape[0] / pessoas_acima_limiar.shape[0]

print(f"Proporção de diabéticos com glicose acima de {limiar_glicose}: {proporcao_diabeticos_acima_limiar}")

plt.figure(figsize=(10, 5))
sns.kdeplot(df_no_outliers[df_no_outliers['Resultado'] == 1]['Glicose'], label='Diabetes', fill=True, color='red')
sns.kdeplot(df_no_outliers[df_no_outliers['Resultado'] == 0]['Glicose'], label='Sem Diabetes', fill=True, color='blue')

plt.axvline(df_no_outliers[df_no_outliers['Resultado'] == 1]['Glicose'].median(), color='darkred', linestyle='--', label='Mediana Diabetes')
plt.axvline(df_no_outliers[df_no_outliers['Resultado'] == 0]['Glicose'].median(), color='darkblue', linestyle='--', label='Mediana Sem Diabetes')

plt.legend()
plt.xlabel('Nível de Glicose')
plt.ylabel('Densidade')
plt.title('Distribuição da Glicose para Pessoas com e sem Diabetes - sem outliers')
plt.show()

# Calcular a média da glicose para cada grupo
media_glicose_diabeticos1 = df_no_outliers[df_no_outliers['Resultado'] == 1]['Glicose'].mean()
media_glicose_nao_diabeticos1 = df_no_outliers[df_no_outliers['Resultado'] == 0]['Glicose'].mean()
print(f"Média da Glicose em Diabéticos: {media_glicose_diabeticos1}")
print(f"Média da Glicose em Não Diabéticos: {media_glicose_nao_diabeticos1}")

# Analisar a glicose em relação a um limiar, por exemplo, 140
limiar_glicose = 150
pessoas_acima_limiar = df_no_outliers[df_no_outliers['Glicose'] > limiar_glicose]
proporcao_diabeticos_acima_limiar1 = pessoas_acima_limiar[pessoas_acima_limiar['Resultado']==1].shape[0] / pessoas_acima_limiar.shape[0]

print(f"Proporção de diabéticos com glicose acima de {limiar_glicose}: {proporcao_diabeticos_acima_limiar1}")

# Criar faixas de glicose
df_no_outliers['Faixa_Glicose'] = pd.cut(df_no_outliers['Glicose'], bins=range(50, 250, 10))

# Calcular a proporção de diabéticos por faixa
proporcao_diabetes = df_no_outliers.groupby('Faixa_Glicose')['Resultado'].mean()

# Plotar
plt.figure(figsize=(12, 5))
proporcao_diabetes.plot(kind='bar', color='red', alpha=0.7)
plt.axhline(0.5, color='black', linestyle='--', label='50% de Diabetes')
plt.xlabel('Faixa de Glicose')
plt.ylabel('Proporção de Diabetes')
plt.title('Proporção de Diabetes por Faixa de Glicose')
plt.xticks(rotation=45)
plt.legend()
plt.show()

"""### Pacientes com maior número de gestações têm maior chance de desenvolver diabetes?"""

# Calcular a correlação entre o número de gestações e o resultado da diabetes
correlation_gravidez_resultado = df_no_outliers['Gravidez'].corr(df_no_outliers['Resultado'])
print(f"Correlação entre Gravidez e Resultado: {correlation_gravidez_resultado}")

plt.figure(figsize=(8, 5))
sns.boxplot(x='Resultado', y='Gravidez', data=df_no_outliers)

plt.xlabel('Resultado (0 = Sem Diabetes, 1 = Com Diabetes)')
plt.ylabel('Número de Gestações')
plt.title('Distribuição do Número de Gestações por Diagnóstico')
plt.show()

df_no_outliers['Faixa_Gestacoes'] = pd.cut(df_no_outliers['Gravidez'], bins=[0, 1, 2, 4, 6, 10, df_no_outliers['Gravidez'].max()],
                               labels=['0-1', '2', '3-4', '5-6', '7-10', '11+'])

proporcao_diabetes = df_no_outliers.groupby('Faixa_Gestacoes')['Resultado'].mean()

plt.figure(figsize=(8,5))
proporcao_diabetes.plot(kind='bar', color='red', alpha=0.7)

plt.xlabel('Número de Gestações')
plt.ylabel('Proporção de Pacientes com Diabetes')
plt.title('Proporção de Diabetes por Faixa de Gestações')
plt.xticks(rotation=0)
plt.show()

"""### É possível criar um modelo preditivo para classificar novos pacientes como diabéticos ou não?

"""

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.preprocessing import StandardScaler

# Separar as features (X) e a variável alvo (y)
X = df_no_outliers.drop('Resultado', axis=1)
y = df_no_outliers['Resultado']

# Dividir os dados em conjuntos de treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Convert 'Faixa_Glicose' to numeric representation before scaling
X_train['Faixa_Glicose'] = X_train['Faixa_Glicose'].cat.codes
X_test['Faixa_Glicose'] = X_test['Faixa_Glicose'].cat.codes

# Now you can proceed with scaling
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Criar e treinar o modelo RandomForestClassifier
model = RandomForestClassifier(random_state=42)
model.fit(X_train, y_train)

# Fazer previsões no conjunto de teste
y_pred = model.predict(X_test)

# Avaliar o modelo
accuracy = accuracy_score(y_test, y_pred)
print(f"Acurácia do modelo: {accuracy}")
print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))

"""### Quais variáveis são mais importantes para prever o risco de diabetes?"""

# Importância das variáveis no modelo treinado
feature_importances = pd.Series(model.feature_importances_, index=X.columns)
feature_importances_sorted = feature_importances.sort_values(ascending=False)
print(feature_importances_sorted)

# Plotar a importância das variáveis
plt.figure(figsize=(10, 6))
sns.barplot(x=feature_importances_sorted.values, y=feature_importances_sorted.index)
plt.title('Importância das Variáveis para Previsão de Diabetes')
plt.xlabel('Importância')
plt.ylabel('Variáveis')
plt.show()